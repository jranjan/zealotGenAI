#!/usr/bin/env python3
"""
Asset Insight Streamlit Dashboard

A comprehensive dashboard for visualizing and exploring asset data generated by the Asset Insight analyser.
"""

import streamlit as st
import json
import os
import sys
from pathlib import Path
import pandas as pd
from datetime import datetime
import plotly.express as px

# Add the parent directory to the path to import AssetAnalyser
sys.path.append(str(Path(__file__).parent.parent))
from analyser import AssetAnalyser, AnalyserFactory
from configreader import SchemaGuide

# Page configuration
st.set_page_config(
    page_title="Asset Insight Dashboard",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #1f77b4;
    }
    .cloud-card {
        background-color: #ffffff;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

class AssetInsightDashboard:
    """Main dashboard class for Asset Insight visualization."""
    
    def __init__(self, analyser_type: str = "owner"):
        self.analyser_type = analyser_type
        self.analyser = self._create_analyser(analyser_type)
        self.config = None
        self.analysis_data = {}
        self.summary_stats = {}
        self.analysis_results = []
        self.temp_files = []  # Track temporary files for cleanup
    
    def _create_analyser(self, analyser_type: str) -> AssetAnalyser:
        """Create the appropriate analyser based on type."""
        return AnalyserFactory.create_analyser(analyser_type)
        
    def load_analysis_data(self):
        """Load analysis data using AssetAnalyser."""
        try:
            st.info("üìÅ Running analysis on all assets")
            
            # Run analysis once for all assets
            self.analysis_results = []
            self.analysis_data = {}
            total_assets = 0
            
            # Run analysis for all assets
            result = self.analyser.analyse_asset_class(
                asset_class_name="Asset",  # Use generic asset class name
                source_path="data/source",  # This should come from config
                result_path="data/results"  # This should come from config
            )
            
            self.analysis_results.append(result)
            
            # Load the generated JSON files for visualization
            result_dir = Path("data/results")  # Placeholder path
            timestamp_dirs = [d for d in result_dir.iterdir() if d.is_dir() and d.name.count('_') == 3]
            if timestamp_dirs:
                latest_dir = max(timestamp_dirs, key=lambda x: x.name)
                json_files = list(latest_dir.glob("*.json"))
                
                for json_file in json_files:
                    try:
                        with open(json_file, 'r') as f:
                            data = json.load(f)
                            
                        cloud_name = data.get('cloud', {}).get('cloud', 'Unknown')
                        self.analysis_data[cloud_name] = data
                        total_assets += data.get('total_assets', 0)
                        
                    except Exception as e:
                        st.warning(f"‚ö†Ô∏è Error loading {json_file.name}: {e}")
                        continue
            
            # Calculate summary statistics
            self.summary_stats = {
                'total_clouds': len(self.analysis_data),
                'total_assets': total_assets,
                'total_teams': sum(
                    len(data.get('cloud', {}).get('team', [])) 
                    for data in self.analysis_data.values()
                ),
                'latest_analysis': datetime.now().strftime("%Y_%m_%d_%H%M%S")
            }
            
            return True
            
        except Exception as e:
            st.error(f"‚ùå Error loading analysis data: {e}")
            return False
    
    def render_sidebar(self):
        """Render the sidebar with navigation and filters."""
        st.sidebar.title("üîç Navigation")
        
        # Debug info
        st.sidebar.markdown("---")
        st.sidebar.markdown("**Debug Info:**")
        st.sidebar.write(f"Analysis data loaded: {bool(self.analysis_data)}")
        st.sidebar.write(f"Config loaded: {bool(self.config)}")
        
        # Test button
        if st.sidebar.button("üß™ Test Button"):
            st.sidebar.success("‚úÖ Sidebar is working!")
        st.sidebar.markdown("---")
        
        # Data source selection
        st.sidebar.subheader("üìÅ Data Source")
        
        # File uploader for configuration
        uploaded_file = st.sidebar.file_uploader(
            "Choose YAML Configuration File",
            type=['yaml', 'yml'],
            help="Upload your assets.yaml configuration file"
        )
        
        # Manual path input as fallback
        st.sidebar.text("OR")
        default_config = "assets.yaml"
        config_path = st.sidebar.text_input(
            "Enter Configuration File Path", 
            value=default_config,
            help="Path to the YAML configuration file"
        )
        
        # Determine which config to use
        if uploaded_file is not None:
            # Save uploaded file temporarily
            temp_config_path = f"temp_{uploaded_file.name}"
            with open(temp_config_path, "wb") as f:
                f.write(uploaded_file.getbuffer())
            # Track for cleanup
            if temp_config_path not in self.temp_files:
                self.temp_files.append(temp_config_path)
            st.sidebar.success(f"‚úÖ Using uploaded file: {uploaded_file.name}")
        
        col1, col2 = st.sidebar.columns(2)
        
        with col1:
            if st.button("üîÑ Run Analysis", type="primary"):
                with st.spinner("Running asset analysis..."):
                    if self.load_analysis_data():
                        st.sidebar.success("‚úÖ Analysis completed successfully!")
                        st.rerun()
                    else:
                        st.sidebar.error("‚ùå Failed to run analysis")
        
        with col2:
            if st.button("üßπ Cleanup"):
                self.cleanup_temp_files()
                st.sidebar.success("‚úÖ Temporary files cleaned up!")
                st.rerun()
        
        if not self.analysis_data:
            return [], []
            
        # Cloud selection
        st.sidebar.subheader("‚òÅÔ∏è Cloud Filter")
        cloud_names = list(self.analysis_data.keys())
        selected_clouds = st.sidebar.multiselect(
            "Select Clouds",
            options=cloud_names,
            default=cloud_names,
            help="Choose which clouds to display"
        )
        
        # Team filter
        st.sidebar.subheader("üë• Team Filter")
        all_teams = set()
        for cloud_data in self.analysis_data.values():
            teams = cloud_data.get('cloud', {}).get('team', [])
            for team in teams:
                if isinstance(team, dict) and 'assets' in team:
                    # Extract team name from assets (first asset's team name)
                    if team['assets']:
                        team_name = team['assets'][0].get('team', 'Unknown Team')
                        all_teams.add(team_name)
        
        selected_teams = st.sidebar.multiselect(
            "Select Teams",
            options=sorted(all_teams),
            default=sorted(all_teams),
            help="Choose which teams to display"
        )
        
        return selected_clouds, selected_teams
    
    def cleanup_temp_files(self):
        """Clean up temporary files."""
        for temp_file in self.temp_files:
            try:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Could not remove temporary file {temp_file}: {e}")
        self.temp_files = []
    
    def render_analysis_summary(self):
        """Render analysis results summary."""
        if not self.analysis_results:
            return
            
        st.subheader("üìä Analysis Results")
        
        # Create results dataframe
        results_data = []
        for result in self.analysis_results:
            results_data.append({
                'Asset Class': result.asset_class,
                'Source Path': result.source_path,
                'Result Path': result.result_path,
                'Total Assets': result.total_assets,
                'Parent Clouds': result.processing_stats.get('parent_clouds_count', 0),
                'Files Created': result.processing_stats.get('files_created', 0),
                'Source Files': result.processing_stats.get('source_files_loaded', 0)
            })
        
        df_results = pd.DataFrame(results_data)
        st.dataframe(df_results, width='stretch')
    
    def render_summary_metrics(self):
        """Render summary metrics at the top of the dashboard."""
        if not self.summary_stats:
            return
            
        st.markdown('<div class="main-header">üìä Asset Insight Dashboard</div>', unsafe_allow_html=True)
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                label="Total Clouds",
                value=f"{self.summary_stats['total_clouds']:,}",
                help="Number of parent clouds"
            )
        
        with col2:
            st.metric(
                label="Total Assets",
                value=f"{self.summary_stats['total_assets']:,}",
                help="Total number of assets across all clouds"
            )
        
        with col3:
            st.metric(
                label="Total Teams",
                value=f"{self.summary_stats['total_teams']:,}",
                help="Total number of teams across all clouds"
            )
        
        with col4:
            st.metric(
                label="Latest Analysis",
                value=self.summary_stats['latest_analysis'],
                help="Timestamp of the latest analysis run"
            )
    
    def render_cloud_overview(self, selected_clouds):
        """Render cloud overview charts."""
        if not self.analysis_data:
            return
            
        st.subheader("‚òÅÔ∏è Cloud Overview")
        
        # Prepare data for charts
        cloud_data = []
        for cloud_name in selected_clouds:
            if cloud_name in self.analysis_data:
                data = self.analysis_data[cloud_name]
                cloud_info = data.get('cloud', {})
                cloud_data.append({
                    'Cloud': cloud_name,
                    'Assets': cloud_info.get('total_cloud_assets', 0),
                    'Teams': cloud_info.get('total_cloud_teams', 0)
                })
        
        if not cloud_data:
            st.warning("No data available for selected clouds")
            return
            
        df = pd.DataFrame(cloud_data)
        
        # Create charts
        col1, col2 = st.columns(2)
        
        with col1:
            fig_assets = px.bar(
                df, 
                x='Cloud', 
                y='Assets',
                title="Assets per Cloud",
                color='Assets',
                color_continuous_scale='Blues'
            )
            fig_assets.update_layout(xaxis_tickangle=-45)
            st.plotly_chart(fig_assets, width='stretch')
        
        with col2:
            fig_teams = px.bar(
                df, 
                x='Cloud', 
                y='Teams',
                title="Teams per Cloud",
                color='Teams',
                color_continuous_scale='Greens'
            )
            fig_teams.update_layout(xaxis_tickangle=-45)
            st.plotly_chart(fig_teams, width='stretch')
    
    def render_cloud_details(self, selected_clouds, selected_teams):
        """Render detailed cloud and team information."""
        if not self.analysis_data:
            return
            
        st.subheader("üìã Cloud Details")
        
        for cloud_name in selected_clouds:
            if cloud_name not in self.analysis_data:
                continue
                
            data = self.analysis_data[cloud_name]
            cloud_info = data.get('cloud', {})
            
            with st.expander(f"‚òÅÔ∏è {cloud_name} ({cloud_info.get('total_cloud_assets', 0)} assets, {cloud_info.get('total_cloud_teams', 0)} teams)", expanded=False):
                
                # Cloud summary
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Total Assets", f"{cloud_info.get('total_cloud_assets', 0):,}")
                with col2:
                    st.metric("Total Teams", f"{cloud_info.get('total_cloud_teams', 0):,}")
                with col3:
                    st.metric("Assets per Team", f"{cloud_info.get('total_cloud_assets', 0) // max(cloud_info.get('total_cloud_teams', 1), 1):,}")
                
                # Teams in this cloud
                teams = cloud_info.get('team', [])
                if teams:
                    st.subheader(f"üë• Teams in {cloud_name}")
                    
                    for i, team in enumerate(teams):
                        if not isinstance(team, dict) or 'assets' not in team:
                            continue
                            
                        team_assets = team.get('assets', [])
                        if not team_assets:
                            continue
                            
                        # Get team name from first asset
                        team_name = team_assets[0].get('team', f'Team {i+1}')
                        
                        # Filter by selected teams
                        if selected_teams and team_name not in selected_teams:
                            continue
                        
                        with st.expander(f"üë• {team_name} ({len(team_assets)} assets)", expanded=False):
                            
                            # Team metrics
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("Assets", len(team_assets))
                            with col2:
                                # Count unique asset classes
                                asset_classes = set(asset.get('assetClass', 'Unknown') for asset in team_assets)
                                st.metric("Asset Classes", len(asset_classes))
                            with col3:
                                # Count unique MBUs
                                mbus = set(asset.get('mbu', 'Unknown') for asset in team_assets)
                                st.metric("MBUs", len(mbus))
                            
                            # Asset table
                            if team_assets:
                                st.subheader("üìã Assets")
                                
                                # Create asset dataframe
                                asset_data = []
                                for asset in team_assets:
                                    asset_data.append({
                                        'ID': asset.get('id', 'N/A'),
                                        'Name': asset.get('name', 'N/A'),
                                        'Identifier': asset.get('identifier', 'N/A'),
                                        'Asset Class': asset.get('assetClass', 'N/A'),
                                        'MBU': asset.get('mbu', 'N/A'),
                                        'FQDN': asset.get('fqdn', 'N/A'),
                                        'Provision Status': asset.get('provision_status', 'N/A'),
                                        'OS Version': asset.get('os_version', 'N/A'),
                                        'Parent Cloud': asset.get('parentCloud', 'N/A'),
                                        'Cloud': asset.get('cloud', 'N/A'),
                                        'Team': asset.get('team', 'N/A')
                                    })
                                
                                df_assets = pd.DataFrame(asset_data)
                                
                                # Display with search and filtering
                                search_term = st.text_input(f"üîç Search assets in {team_name}", key=f"search_{cloud_name}_{i}")
                                if search_term:
                                    mask = df_assets.astype(str).apply(lambda x: x.str.contains(search_term, case=False, na=False)).any(axis=1)
                                    df_assets = df_assets[mask]
                                
                                st.dataframe(
                                    df_assets,
                                    width='stretch',
                                    height=400
                                )
    
    def render_asset_analytics(self, selected_clouds):
        """Render asset analytics and insights."""
        if not self.analysis_data:
            return
            
        st.subheader("üìà Assets Analytics")
        
        # Collect all assets for analysis
        all_assets = []
        for cloud_name in selected_clouds:
            if cloud_name not in self.analysis_data:
                continue
                
            data = self.analysis_data[cloud_name]
            teams = data.get('cloud', {}).get('team', [])
            
            for team in teams:
                if isinstance(team, dict) and 'assets' in team:
                    all_assets.extend(team.get('assets', []))
        
        if not all_assets:
            st.warning("No assets available for analysis")
            return
        
        # Asset class distribution
        asset_classes = [asset.get('assetClass', 'Unknown') for asset in all_assets]
        class_counts = pd.Series(asset_classes).value_counts()
        
        col1, col2 = st.columns(2)
        
        with col1:
            fig_class = px.pie(
                values=class_counts.values,
                names=class_counts.index,
                title="Asset Class Distribution"
            )
            st.plotly_chart(fig_class, width='stretch')
        
        # MBU distribution
        mbus = [asset.get('mbu', 'Unknown') for asset in all_assets]
        mbu_counts = pd.Series(mbus).value_counts()
        
        with col2:
            fig_mbu = px.bar(
                x=mbu_counts.index,
                y=mbu_counts.values,
                title="MBU Distribution",
                labels={'x': 'MBU', 'y': 'Count'}
            )
            fig_mbu.update_layout(xaxis_tickangle=-45)
            st.plotly_chart(fig_mbu, width='stretch')
        
        # Provision status
        provision_status = [asset.get('provision_status', 'Unknown') for asset in all_assets]
        status_counts = pd.Series(provision_status).value_counts()
        
        col1, col2 = st.columns(2)
        
        with col1:
            fig_status = px.bar(
                x=status_counts.index,
                y=status_counts.values,
                title="Provision Status Distribution",
                labels={'x': 'Status', 'y': 'Count'}
            )
            st.plotly_chart(fig_status, width='stretch')
        
        # OS Version distribution (top 10)
        os_versions = [asset.get('os_version', 'Unknown') for asset in all_assets]
        os_counts = pd.Series(os_versions).value_counts().head(10)
        
        with col2:
            fig_os = px.bar(
                x=os_counts.values,
                y=os_counts.index,
                orientation='h',
                title="Top 10 OS Versions",
                labels={'x': 'Count', 'y': 'OS Version'}
            )
            st.plotly_chart(fig_os, width='stretch')
    
    def run(self):
        """Run the main dashboard."""
        # Clean up any existing temporary files on startup
        self.cleanup_temp_files()
        
        
        # Sidebar
        selected_clouds, selected_teams = self.render_sidebar()
        
        if not self.analysis_data:
            st.info("üëà Please load analysis data using the sidebar to get started.")
            st.markdown("""
            **To get started:**
            1. **Upload a YAML file** using the file picker in the sidebar, OR
            2. **Enter the path** to your `assets.yaml` file in the text box
            3. **Click "Run Analysis"** to process your data
            
            **Example configuration file path:** `assets.yaml`
            """)
            return
        
        # Main content
        self.render_summary_metrics()
        
        # Tabs for different views
        tab1, tab2, tab3, tab4 = st.tabs(["üìä Overview", "üìã Details", "üìà Analytics", "üîç Analysis Results"])
        
        with tab1:
            self.render_cloud_overview(selected_clouds)
        
        with tab2:
            self.render_cloud_details(selected_clouds, selected_teams)
        
        with tab3:
            self.render_asset_analytics(selected_clouds)
        
        with tab4:
            self.render_analysis_summary()

def main():
    """Main function to run the Streamlit app."""
    # Add analyser type selection
    st.sidebar.markdown("### üîß Configuration")
    analyser_type = st.sidebar.selectbox(
        "Select Analyser Type",
        AnalyserFactory.get_available_types(),
        index=0,
        help="Choose the type of analysis to perform"
    )
    
    dashboard = AssetInsightDashboard(analyser_type=analyser_type)
    dashboard.run()

if __name__ == "__main__":
    main()
